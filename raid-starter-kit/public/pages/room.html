<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ë°© - Raid Starter Kit</title>
  <link rel="stylesheet" href="../styles/base.css">
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="row" style="justify-content: space-between;">
        <div>
          <h1 style="margin: 0; font-size: 24px;">ğŸ° Raid Room</h1>
        </div>
        <div class="row">
          <a href="lobby.html" class="btn">ë¡œë¹„ë¡œ</a>
        </div>
      </div>
    </div>
  </header>

  <div class="container grid" style="grid-template-columns: 1fr 450px;">
    <section>
      <div id="aiChat"></div>
      <div style="height: 16px;"></div>
      <div id="genChat"></div>
    </section>

    <aside>
      <div id="roomMeta" class="card"></div>
      <div style="height: 16px;"></div>
      <div id="slots"></div>
      <div style="height: 16px;"></div>
      <div class="card" id="hostCtrl" style="display: none;">
        <h4>í˜¸ìŠ¤íŠ¸ ì»¨íŠ¸ë¡¤</h4>
        <div class="row" style="margin-bottom: 8px; align-items:center;">
          <label class="meta" style="min-width:84px">í”„ë¡¬í”„íŠ¸</label>
          <select id="promptSel" class="input" style="max-width: 260px"></select>
          <a href="prompt.html" class="btn">í¸ì§‘</a>
        </div>
        <div class="row" style="margin-bottom: 8px; align-items:center;">
          <label class="meta" style="min-width:84px">API í‚¤</label>
          <input id="apiKey" class="input" placeholder="Gemini API Key" style="max-width: 260px">
          <button id="saveKey" class="btn">ì €ì¥</button>
        </div>
        <div class="card" style="margin-bottom:8px">
          <b>ë¯¸ë¦¬ë³´ê¸°</b>
          <pre id="promptPreview" class="mono" style="white-space:pre-wrap; max-height:160px; overflow:auto; margin-top:6px"></pre>
        </div>
        <div class="row" style="margin-bottom: 8px;">
          <input id="speaker" class="input" placeholder="ë°œí™” ìŠ¬ë¡¯ (ìˆ«ì)" style="max-width: 150px;">
          <button id="setSp" class="btn">ë°œí™”ì ì§€ì •</button>
        </div>
        <div class="row">
          <button id="runPrompt" class="btn">í”„ë¡¬í”„íŠ¸ ì‹¤í–‰</button>
          <button id="start" class="btn primary">ê²Œì„ ì‹œì‘</button>
        </div>
      </div>
    </aside>
  </div>

  <script type="module">
    import { Store } from '../core/store.js';
    import { API } from '../core/api.js';
    import { WS } from '../core/ws.js';
    import { mountGeneralChat } from '../components/chat-general.js';
    import { mountAiChat } from '../components/chat-ai.js';
    import { mountSlotsGrid } from '../components/slots-grid.js';

    // URL íŒŒë¼ë¯¸í„°ì—ì„œ ë°© ID ê°€ì ¸ì˜¤ê¸°
    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    
    if (!roomId) {
      alert('ë°© IDê°€ ì—†ìŠµë‹ˆë‹¤');
      location.href = 'lobby.html';
    }

    const clientId = Store.state.clientId;
    const myName = () => Store.state.name;

    // WebSocket ì—°ê²°
    WS.connect();
    WS.join(roomId, clientId, myName());

    // ì±„íŒ… ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸
    const genChat = mountGeneralChat(document.getElementById('genChat'), {
      roomId,
      clientId,
      nameGetter: myName
    });

    const aiChat = mountAiChat(document.getElementById('aiChat'), {
      roomId,
      clientId,
      nameGetter: myName
    });

    // ìŠ¬ë¡¯ ê·¸ë¦¬ë“œ ë§ˆìš´íŠ¸
    const slotsGrid = mountSlotsGrid(document.getElementById('slots'), {
      host: false,
      async onClaim(slotNo) {
        const char = Store.state.roster[0] || null;
        if (!char) {
          alert('ë¡œìŠ¤í„°ì— ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìºë¦­í„°ë¥¼ ì¶”ê°€í•˜ì„¸ìš”.');
          return;
        }
        
        try {
          await API.claim(roomId, {
            clientId,
            name: myName(),
            slotNo,
            char
          });
          refresh();
        } catch (error) {
          alert('ìŠ¬ë¡¯ ì ìœ  ì‹¤íŒ¨: ' + error.message);
        }
      },
      async onRelease() {
        try {
          await API.release(roomId, { clientId });
          refresh();
        } catch (error) {
          alert('ìŠ¬ë¡¯ í•´ì œ ì‹¤íŒ¨: ' + error.message);
        }
      },
      async onReady() {
        try {
          await API.ready(roomId, { clientId });
          refresh();
        } catch (error) {
          alert('ì¤€ë¹„ ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨: ' + error.message);
        }
      },
      async onKick(slotNo) {
        if (!confirm('ì´ í”Œë ˆì´ì–´ë¥¼ ì¶”ë°©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        
        try {
          await API.kick(roomId, { clientId, targetSlot: slotNo });
          refresh();
        } catch (error) {
          alert('ì¶”ë°© ì‹¤íŒ¨: ' + error.message);
        }
      }
    });

    const metaBox = document.getElementById('roomMeta');
    const hostBox = document.getElementById('hostCtrl');
    const promptSel = document.getElementById('promptSel');
    const promptPreview = document.getElementById('promptPreview');
    const apiKeyInput = document.getElementById('apiKey');
    const saveKeyBtn = document.getElementById('saveKey');

    // ë°© ì •ë³´ ìƒˆë¡œê³ ì¹¨
    async function refresh() {
      try {
        const { room } = await API.getRoom(roomId);
        render(room);
      } catch (error) {
        console.error('ë°© ì •ë³´ ë¡œë“œ ì‹¤íŒ¨:', error);
      }
    }

    // ë°© ì •ë³´ ë Œë”ë§
    function render(room) {
      metaBox.innerHTML = `
        <h4>${room.title}</h4>
        <div class="meta">${room.desc}</div>
        <div class="meta">ìƒíƒœ: ${room.status} Â· ëª¨ë“œ: ${room.aiMode} Â· ë°œí™”ì: ${room.speakerSlot}</div>
      `;

      slotsGrid.render(room, clientId);

      // í˜¸ìŠ¤íŠ¸ ì—¬ë¶€ í™•ì¸ (ë°© ìƒì„±ìê°€ í˜¸ìŠ¤íŠ¸)
      const isHost = room.hostId === clientId;
      slotsGrid.setHost(isHost);
      hostBox.style.display = isHost ? 'block' : 'none';
      if (isHost) {
        const prompts = Store.loadPrompts();
        promptSel.innerHTML = (prompts || []).map(p => `<option value="${p.id}">${p.label || p.id}</option>`).join('') || '<option value="">(ì €ì¥ëœ í”„ë¡¬í”„íŠ¸ ì—†ìŒ)</option>';
        const last = localStorage.getItem('RSK_ROOM_PROMPT_'+room.id) || '';
        promptSel.value = last;
        apiKeyInput.value = localStorage.getItem('RSK_ROOM_APIKEY_'+room.id) || '';
        updatePreview(room);
      }

      // AI ì±„íŒ… ë°œí™”ê¶Œ ì—…ë°ì´íŠ¸
      const mySlot = room.slots.find(s => s.playerId === clientId);
      const canSpeak = isHost || room.aiMode === 'free' || room.speakerSlot === mySlot?.slotNo;
      aiChat.updateSpeak(canSpeak, room.aiMode, room.speakerSlot);
    }

    // í˜¸ìŠ¤íŠ¸ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸
    promptSel?.addEventListener('change', () => {
      localStorage.setItem('RSK_ROOM_PROMPT_'+roomId, promptSel.value || '');
      updatePreviewCache();
    });

    saveKeyBtn?.addEventListener('click', () => {
      localStorage.setItem('RSK_ROOM_APIKEY_'+roomId, (apiKeyInput.value||'').trim());
      alert('API í‚¤ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤ (ë¡œì»¬)');
    });

    function updatePreviewCache(){
      // ìµœì‹  ë°© ìƒíƒœë¡œ ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ 
      API.getRoom(roomId).then(({room})=> updatePreview(room)).catch(()=>{});
    }

    function updatePreview(room){
      const prompts = Store.loadPrompts();
      const cur = prompts.find(p => p.id === (promptSel.value||''));
      if (!cur){ promptPreview.textContent = ''; return; }
      promptPreview.textContent = expandTemplate(cur.text||'', room);
    }

    // í…œí”Œë¦¿ ì¹˜í™˜ê¸°
    function expandTemplate(tpl, room){
      function getSlot(n){ return room.slots?.find(s=>s.slotNo===n) || {}; }
      function charAll(c){ if(!c) return ''; const lines=[]; lines.push(`${c.name||''}`); if(c.title) lines.push(`- ${c.title}`); if(c.desc) lines.push(c.desc); (c.abilities||[]).forEach((a,i)=>{ if(a?.name||a?.text) lines.push(`â€¢ (${i+1}) ${a.name||''} â€” ${a.text||''}`); }); return lines.filter(Boolean).join('\n'); }
      return (tpl||'').replace(/\{\{\s*([\w.\[\]]+)\s*\}\}/g, (_, key)=>{
        if(key.startsWith('slot')){
          const m = key.match(/^slot(\d+)\.(.+)$/); if(!m) return '';
          const n = parseInt(m[1],10); const rest=m[2]; const slot=getSlot(n); const c=slot.char||{};
          if(rest==='char.all') return charAll(c);
          if(rest.startsWith('char.abilities[')){
            const mm = rest.match(/^char\.abilities\[(\d+)\]\.(name|text)$/); if(!mm) return '';
            const idx=parseInt(mm[1],10)-1; const field=mm[2]; return c.abilities?.[idx]?.[field]||'';
          }
          const map={ 'char.name':c.name,'char.desc':c.desc,'char.title':c.title };
          return map[rest]||'';
        }
        if(key.startsWith('me.')){
          const mySlot = room.slots.find(s=>s.playerId===clientId);
          return expandTemplate(`{{slot${mySlot?.slotNo||1}.${key.slice(3)}}}`, room);
        }
        if(key==='room.title') return room.title||'';
        if(key==='room.desc') return room.desc||'';
        return '';
      });
    }

    async function callGemini(apiKey, text){
      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(apiKey)}`;
      const body={ contents:[{ role:'user', parts:[{ text }] }] };
      const r = await fetch(url,{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      if(!r.ok) throw new Error('HTTP '+r.status);
      const j = await r.json();
      const out = j?.candidates?.[0]?.content?.parts?.map(p=>p.text||'').join('\n') || '(ë¹ˆ ì‘ë‹µ)';
      return out;
    }

    document.getElementById('runPrompt')?.addEventListener('click', async () => {
      const prompts = Store.loadPrompts();
      const cur = prompts.find(p => p.id === (promptSel.value||''));
      if (!cur) { alert('í”„ë¡¬í”„íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”'); return; }
      const key = (apiKeyInput.value||'').trim() || localStorage.getItem('RSK_ROOM_APIKEY_'+roomId) || '';
      if (!key) { alert('API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤'); return; }
      try{
        // ë°© ìƒíƒœ ê°€ì ¸ì™€ ì¹˜í™˜
        const { room } = await API.getRoom(roomId);
        const expanded = expandTemplate(cur.text||'', room);
        const resp = await callGemini(key, expanded);
        await API.runPrompt(roomId, { clientId, text: resp });
      }catch(e){
        alert('í”„ë¡¬í”„íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: '+e.message);
      }
    });

    hostBox.querySelector('#setSp').onclick = async () => {
      const slotNo = parseInt(hostBox.querySelector('#speaker').value, 10);
      if (!slotNo) return;
      
      try {
        await API.speaker(roomId, { clientId, slotNo });
        refresh();
      } catch (error) {
        alert('ë°œí™”ì ì§€ì • ì‹¤íŒ¨: ' + error.message);
      }
    };

    hostBox.querySelector('#start').onclick = async () => {
      try {
        await API.start(roomId, { clientId });
      } catch (error) {
        alert('ê²Œì„ ì‹œì‘ ì‹¤íŒ¨: ' + error.message);
      }
    };

    // WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    WS.on('ROOM_STATE', (message) => {
      if (message.room?.id === roomId) {
        render(message.room);
      }
    });

    WS.on('CHAT_PUSH', (message) => {
      const msg = message.message;
      if (!msg || msg.roomId !== roomId) return;
      
      if (msg.kind === 'ai') {
        aiChat.log.push(msg.name, msg.text);
      } else {
        genChat.push(msg.name, msg.text);
      }
    });

    WS.on('COUNTDOWN_TICK', (message) => {
      genChat.sys('ê²Œì„ ì‹œì‘ê¹Œì§€ ' + message.n + 'ì´ˆ...');
    });

    WS.on('COUNTDOWN_DONE', (message) => {
      location.href = 'raid.html?room=' + roomId + '&startAt=' + message.startAt;
    });

    // ì´ˆê¸°í™”
    refresh();
  </script>
</body>
</html>
